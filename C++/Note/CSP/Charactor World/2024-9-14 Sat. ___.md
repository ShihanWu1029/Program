# Dynamic Programing 动态规划

- Author：吴诗翰
- Time：2024-9-14
- Agency： 浩家军

## 两个性质

### 无后效性

指的是在某个阶段的状态一旦确定，那么在这个阶段之后的过程中，决策的选择就不会受到之前阶段状态和决策的影响。换句话说，一个阶段的决策只依赖于当前状态，而与之前的历史状态无关。

### 最优子结构

指的是一个问题的最优解包含了其子问题的最优解，即可以通过组合子问题的最优解来构造出原问题的最优解。

## Stones 报数

AB两人分别从零开始报数

![](./屏幕截图%202024-09-14%20192809.png)

## Coins 硬币

https://www.luogu.com.cn/problem/AT_dp_i

我们这样定义状态，定义$dp[i][j]$为到第i个硬币时有j个是正面的概率。那么所求答案为$sum\{ dp[n][i] \ \ \ or \ \ \ (n+1)/2<=i<=n\}$

题目说了n为odd，

那么状态转移即为： 
$$
dp[i][j]=dp[i-1][j-1]*p[i]+dp[i-1][j]*(1.0-p[i]);
$$

意思为，到了第i个硬币时，j个正面朝上的状态可以由以下两个状态转移过来：

1、第i-1个硬币的时候，有j-1个正面朝上的，第i个硬币也正面朝上。

2、第i-1个硬币的时候，有j个正面朝上的，第i个硬币反面朝上。

然后初始状态定义:

```cpp
dp[1][1]=p[1];
dp[1][0]=1.0000000-p[1];
```

$etc.$

## Permutation 排列

### 题目大意：

给定长度为$n-1$的串（由<或者>构成），问有多少种排列$p_1 ,..., p_n$满足：

- `if s[i]=='<' then p[i]<p[i+1]`

- `if s[i]=='>' then p[i]>p[i+1]`

### 思路

$dp[i][j]$表示前$i$位，用$1$ ~ $i$填充$p_1$ ~ $p_i$且$p_i=j$的合法方案数量。

那么我们知道
如果当前是 < 号
dp[i][1] = 0 （前面1 - i-1 序列没有比 1 小的）
dp[i][2] = dp[i-1][1]
dp[i][3] = dp[i-1][2] + dp[i-1][1]
…
dp[i][j] = dp[i][j-1] + dp[i-1][j-1]

如果是 > 号
我们则需要把比 j 大的都加上 1
就是 1 - i-1序列 把比 j 大的都加 1 你就可以插入 j 形成 1 - i 序列了
dp[i][i] = 0（前面 1 - i-1 序列没有比 i 大的）
dp[i][i-1] = dp[i-1][i-1]
dp[i][i-2] = dp[i-1][i-1] + dp[i-1][i-2]
…
dp[i][j] = dp[i][j+1] + dp[i-1][j]


## 快乐的蜜月

![](./屏幕截图%202024-09-14%20215146.png)