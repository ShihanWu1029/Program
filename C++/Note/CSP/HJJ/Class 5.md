# Class 5

## LIS

### 算法一

以序列最后一位映射长度

$dp_i$ 表示到第 $i$ 位的最长长度。

### 算法二

以长度映射最后一位

$low_i$ 表示目前为止长度为 $i$ 最后一位最小是多少。

新建一个 $low$ 数组， $low_i$ 表示长度为 $i$ 的LIS结尾元素的最小值。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护 $low$ 数组，对于每一个 $a_i$ ，如果 $a_i \gt low_{当前最长的LIS长度}$ ，就把 $a_i$ 接到当前最长的LIS后面，即 $low_{当前最长的LIS长度+1} = a_i$ 。 
那么，怎么维护 $low$ 数组呢？
对于每一个 $a_i$ ，如果 $a_i$ 能接到 LIS 后面，就接上去；否则，就用 $a_i$ 取更新 $low$ 数组。具体方法是，在 $low$ 数组中找到第一个大于等于 $a_i$ 的元素 $low_j$ ，用 $a_i$ 去更新 $low_j$ 。如果从头到尾扫一遍 $low$ 数组的话，时间复杂度仍是 $O(n^2)$。我们注意到 $low$ 数组内部一定是单调不降的，所有我们可以二分 $low$ 数组，找出第一个大于等于 $a_i$ 的元素。二分一次 $low$ 数组的时间复杂度的 $O(log n)$，所以总的时间复杂度是 $O(nlogn)$。


## 背包

### 定义

物品数量： $n$

背包容量： $w$

物品 $i$ 体积： $w_i$

物品 $i$ 价值： $v_i$

物品 $i$ 选择的数量： $x_i$

约束： $ \sum_{i=1}^{n} \le w$

目标： $max(\sum_{i=1}^{n} v_i \times x_i)$

### 01背包

#### 概念

有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

#### 解法

##### 二维数组
对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

那么可以有两个方向推出来dp[i][j]，

- 由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]

- 由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。

在看其他情况。

状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？

dp[i][j]在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，因为0就是最小的了，不会影响取最大价值的结果。

如果题目给的价值有负数，那么非0下标就要初始化为负无穷了。例如：一个物品的价值是-2，但对应的位置依然初始化为0，那么取最大值的时候，就会取0而不是-2了，所以要初始化为负无穷。

而背包问题的物品价值都是正整数，所以初始化为0，就可以了。

这样才能让dp数组在递归公式的过程中取最大的价值，而不是被初始值覆盖了。

那么先遍历物品还是先遍历背包重量呢？

其实都可以！！ 但是先遍历物品更好理解。

```cpp 
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组里元素的变化
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

##### 滚动数组优化

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

于其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j]，一个是取dp[j - weight[i]] + value[i]，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

代码如下：

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

### 完全背包

#### 概念




### 多重背包

### 混合背包

### 分组背包

### 树形依赖背包

