# 动态规划

请于环境明亮处阅读

---

## 什么是动态规划<br>
> 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br>
> 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br>
> 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。<br>
> 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

以上内容来自维基百科，通过这段文字，我们可以大概地了解动态规划的概念。但是单纯的文字显然不是那么容易理解，所以接下来以求最长上升子序列(LIS)为例，初步感受动态规划的作用

> 对于序列a1, a2, a3... an 来说，对于它的一个子序列ai1, ai2... aii ，其中满足ai1 <= ai2 <= ... <= aii ，且满足i1 < i2 < ... < ii ，则可以成这个子序列为该序列的一段上升子序列。求给定的长度为n的序列的最长上升子序列的长度。

显然利用朴素算法解决这个问题会非常困难，但是利用动态规划的思想可以大幅度的降低复杂度。此题目的大问题是求给定的长度为n的序列的最长上升子序列的长度，那么该如何选取合适的子问题呢？对于动态规划中子问题的选取，我们通常要保证子问题拥有以下三个性质：

1.**最优子结构性质**：每个子问题的解都是最优的

2.**无后效性**：一个子问题得到了解之后就不会再变化，之后其他子问题的解都不会对它产生影响

3.**子问题重叠性**：在对其中一个子问题求解时，我们需要利用其他子问题的解来解决问题，动态规划的思想通过这个性质来避免朴素问题中的重复计算的问题

基于以上性质，我们选取**前i项中最长上升子序列的长度**作为子问题，可以直接看出这个子问题满足前两个性质。而第三个性质我们通常通过**状态转移方程**来体现。设 f[i] 为前 i 项中最长上升子序列的长度，我们可以得到递推公式：
```
f[i] = max{f[j] | j < i && a[j] <= a[i]} + 1
```
其中`f[1] = 1`。

这个递推公式就是所谓的状态转移方程，其中的状态就对应选定的子问题，状态转移对应子问题之间的关系，递推方程的边界情况对应边界子问题。通过递推公式即可得到所有子问题的解，进而得到最终问题的答案。

整理一下思路，我们可以发现解决动态规划问题的关键就是找到合适的子问题并确定合适的动态转移方程。接下来会介绍一些常规套路，便于我们快速得到问题的解法

## 一维动规
形似 n个东西排成一排，以某种特殊的要求选取其中的若干个，求最优的解决方案 的问题我们通常可以认为是一维动规问题，上面的例题LIS就是一个典型的一维动规问题。一维动规中比较典型的状态转移方程有：

dp[i]：在前 i 个物品中的最优方案

dp[i][0/1]；在前 i 个物品中，选择第 i 个物品和不选择第 i 个物品时的最优方案

dp[i][j]：在前 i 个物品中选择 j 个物品时的最优方案

以LIS(最长上升子序列)为例，以下为关键部分代码:  
```cpp
f[1] = 1;
for(int i=2; i<=n; i++)
{
    f[i] = 1;
    for(int j=1; j<i; j++)
    {
        if(a[i] >= a[j])
        {
            f[i] = max(f[i], f[j]+1);
        }
    }
}
```

## 背包问题

背包问题是一种很著名的题目模型，通常格式为：有N个物体，每个物体有自己的体积 Wi 和价值 Vi，要求从中选出总体积不超过V的几个物品，使总价值尽可能的大。

背包问题可以基于这个模型产生很多变化，比如每个物品的数量可以是一个（01背包）、无数个（完全背包）或者各有 n[i] 个（多重背包），物品之间可能会相互冲突（分组背包）或者相互依赖（有依赖性的背包问题），背包的体积是多维的（多维背包）等等类型，本文受篇幅限制只会简单介绍一下01背包，不过有一篇著名的博客《**背包九讲**》详尽地讲解了以上这些模型（链接附于文末），感兴趣的同学一定要去读一下。

### 01背包

再复读一下题目

> 有 N 件物品和一个容量为 V 的背包，第 i 件物品的体积是 Ci ，价值是 Wi ，求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

01背包问题的特点是每个物品只有两个状态：放入背包或者不放。有的人可能打算把物品按照价格除以体积得到的“单价”进行排序，然后把单价较高的物品优先放到背包里。可惜这种贪心策略并不正确，比如当背包容积为10时，有

> W1 = 8, C1 = 9<br>
> W2 = 3, C2 = 3<br>
> W3 = 4, C3 = 4<br>
> W4 = 3, C4 = 3<br>

这四个物品，按照上面的贪心策略，很容易得出

> v1 = 9 / 8 = 1.125<br>
> v2 = 1<br>
> v3 = 1<br>
> v4 = 1<br>

所以我们将第一个物品放入了包中，但是此时的最优解是取第 2，3，4 个物品装入背包，此时的价值为 10 > 9。所以本题不能使用贪心策略。采用动态规划的思想可以更好地解决问题。

既然要用动态规划，那我们就要先确定子问题。不难看出子问题可以描述为**将前 i 个物品放入容积为 j 的背包中可以得到的最大价值**，可以用`f[i][j]`来记录当前子问题的状态。

对于当前状态`f[i][j]`来说，若只考虑是否选择第 i 个物品，那么问题的其他部分就只与前 i-1 个物品时的状态有关。如果我们选择了第 i 个物品，那么`f[i][j] = f[i-1][j-c[i]] + w[i]`，即在前 i-1 个物品中当背包体积为`f[i][j] = f[i-1][j-c[i]] + w[i]`时得到的最大价值加上第 i 件物品的价值；同样，如果我们不选择第 i 件物品，那么`f[i][j] = f[i-1][j]`。即在同样背包容量下前 i-1 个物品能得到的最大价值。两种状态中的最优解就是该子问题的解。

所以我们现在可以确定状态转移方程了: 关键代码如下`f[i][j] = max(f[i-1][j-c[i]] + w[i], f[i-1][j])`

```cpp
for(int i=1; i<=n; i++)
{
    for(int j=V; j>=0; j--)
    {
        if(j >= c[i])//判断当前背包是否能装下该物品
        {
            f[i][j] = max(f[i-1][j-c[i]] + w[i], f[i-1][j]);
        }
        else
        {
            f[i][j] = f[i-1][j];
        }
    }
}
```

#### 01背包的空间优化
我们可以注意到，每在递推到`n = i`时，我们只用到了`n = i - 1`时的`f[i-1][j-c[i]]`和`f[i-1][j]`两种状态。那么只要我们将 j 以`V ~ 0`的方向递推，以上的数据就可以都存在一个一维数组里。如图：

![示例](https://img1.imgtp.com/2023/08/18/25xZI2mp.png)

此时的状态转移方程可以变成`f[j] = max(f[j], f[j-c[i]])`，空间复杂度从`O(VN)`降成`O(V)`。

## 区间动规
区间动规通常处理的数据也是一维的，它与一维动规的区别是区间动规常常是以连续的一段的数据作为整体，常见的状态形式为 `dp[l][r]` 代表区间为 `[l, r]` 的这段数据中的最佳结果，通常边界情况是 `l >= r`。

>给定一个由小括号和中括号构成的序列，请插入尽量少的小括号和中括号，使序列合法

>例：`([(]` 答案：`()[()]` 或 `([()])`

这里跳过思考过程，直接列出状态转移方程如下

`dp[l][r]` 表示将区间 `[l, r]` 变成合法序列最少要插入的符号数

当第 l 个字符和第 r 个字符恰好可以凑成一对时

```cpp
dp[l][r] = min(dp[l+1][r-1], min(dp[i][k], dp[k+1][r]))
```

边界条件为  `dp[i][i] = 1`

## 贪心动规

在动态规划中求解子问题的最优解时，我们可能会用到贪心思想进行优化。

>贪心思想：在求解过程中总是做出当前最好的选择，此时的求解方式通常比较简单直接，但是不一定可以保证正确性

在动态规划中，如果我们能找到一个正确的贪心方法来代替一般的枚举过程，那么算法的时间复杂度会得到不错的优化，但是一个看似正确的贪心策略也许会是狡猾的出题人留下的陷阱（比如上面提到过的01背包的错误解法）。

## 写在最后
以上是本次报告中动态规划的基础部分，动态规划题目的难度上下限差别很大，而且这种思想在很多常见算法中都有涉及，请尽量耐心理解。

[背包九讲]("https://www.cnblogs.com/jbelial/articles/2116074.html")

[原文链接]("https://github.com/CSGrandeur/s-1problem1day1ac/discussions/70")

[进阶篇]("https://github.com/CSGrandeur/s-1problem1day1ac/discussions/84")